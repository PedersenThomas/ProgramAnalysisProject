/*
 * ANTRL (http://www.antlr.org/) grammar for the project language. You will
 * probably want to adapt the file to generate parser for your language of
 * choice and use your own data structures (or define tree parser to traverse
 * the tree generated by ANTLR).
 *
 * Note that this has not been throughly tested, so let us know if there are
 * any problems.
 */

grammar TheLang;

options {
  language= Java;  /* Change this to generate parser for some other language. */
  /* backtrack = true;
  memoize = true;
  output = AST;
  ASTLabelType = CommonTree; */
}

tokens {
  AND = '&';
  OR = '|';
  ASSIGN = ':=';
  SEMI = ';';
  GT = '>';
  GE = '>=';
  LT = '<';
  LE = '<=';
  EQ = '=';
  NEQ = '!=';
  PLUS = '+';
  MINUS = '-';
  MUL = '*';
  DIV = '/';
  NOT = '!';
  LPAREN = '(';
  RPAREN = ')';
  LBRACE = '{';
  RBRACE = '}';
  LBRACKET = '[';
  RBRACKET = ']';
  COLON = ':';
  IF = 'if';
  THEN = 'then';
  ELSE = 'else';
  FI = 'fi';
  WHILE = 'while';
  DO = 'do';
  OD = 'od';
  SKIP = 'skip';
  WRITE = 'write';
  READ = 'read';
  PROGRAM = 'program';
  END = 'end';
  TRUE = 'true';
  FALSE = 'false';
  INT = 'int';
  LOW = 'low';
  HIGH = 'high';
}

@header {
package thelang;

import ast.*;
}

@lexer::header {
package thelang;

}

bexpr returns [BooleanExpression value] : 
	b1=bexpr1      { $value = b1; }
	 (OR b2=bexpr1 { $value = new BooleanOperation($value, BooleanOperator.Or, b2); } )* 
      ;

bexpr1 returns [BooleanExpression value] 
	: b1=bexpr2       { $value = b1; }
	   (AND b2=bexpr2 { $value = new BooleanOperation($value, BooleanOperator.And, b2); } )*
    ;

bexpr2 returns [BooleanExpression value]
	: NOT b=bexpr           { $value = new NotBooleanExpression(b); }
    | TRUE                  { $value = new BooleanConstant(true); }
    | FALSE                 { $value = new BooleanConstant(false); }
    | LPAREN c=bexpr RPAREN { $value = c; }
    ;

skipStmt returns [SkipStatement value]
	: SKIP SEMI { $value = new SkipStatement(); }
	;

ifStmt returns [IfStatement value] : 
	IF b=bexpr THEN t=stmt+ ELSE f=stmt+ FI { $value = new IfStatement(b, t, f); }
	;
	
stmt returns [Statement value] 
	: s=skipStmt { $value = s; }
    | i=ifStmt { $value = i; }
	;

program returns [Program value]
	: PROGRAM s=stmt END { $value = new Program(null, s); }
	;

COMMENT : '(*' (options {greedy=false;} : .)* '*)' {$channel=HIDDEN;}
     ;

INTEGER : ('0' | '1'..'9' '0'..'9'*);

IDENTIFIER : LETTER (LETTER|'0'..'9')* ;

fragment
LETTER : 'A'..'Z'
       | 'a'..'z'
       | '_'
       ;

WS : (' '|'\r'|'\t'|'\u000C'|'\n') { skip(); } ;
