/*
 * ANTRL (http://www.antlr.org/) grammar for the project language. You will
 * probably want to adapt the file to generate parser for your language of
 * choice and use your own data structures (or define tree parser to traverse
 * the tree generated by ANTLR).
 *
 * Note that this has not been throughly tested, so let us know if there are
 * any problems.
 */

grammar TheLang;

options {
  language= Java;  /* Change this to generate parser for some other language. */
  /* backtrack = true;
  memoize = true;
  output = AST;
   ASTLabelType = CommonTree; */
}

tokens {
  AND = '&';
  OR = '|';
  ASSIGN = ':=';
  SEMI = ';';
  GT = '>';
  GE = '>=';
  LT = '<';
  LE = '<=';
  EQ = '=';
  NEQ = '!=';
  PLUS = '+';
  MINUS = '-';
  MUL = '*';
  DIV = '/';
  NOT = '!';
  LPAREN = '(';
  RPAREN = ')';
  LBRACE = '{';
  RBRACE = '}';
  LBRACKET = '[';
  RBRACKET = ']';
  COLON = ':';
  IF = 'if';
  THEN = 'then';
  ELSE = 'else';
  FI = 'fi';
  WHILE = 'while';
  DO = 'do';
  OD = 'od';
  SKIP = 'skip';
  WRITE = 'write';
  READ = 'read';
  PROGRAM = 'program';
  END = 'end';
  TRUE = 'true';
  FALSE = 'false';
  INT = 'int';
  LOW = 'low';
  HIGH = 'high';
}

@header {
package thelang;

import ast.*;
}

@lexer::header {
package thelang;

}

aexpr returns [ArithmeticExpression value]
	: l=aexpr1 { $value = l; } 
		(   PLUS  r1=aexpr1 { $value = new ArithmeticOperation($value, ArithmeticOperator.Plus, r1); } 
		  | MINUS r2=aexpr1 { $value = new ArithmeticOperation($value, ArithmeticOperator.Minus, r2); } 
		)* 
	;

aexpr1 returns [ArithmeticExpression value]
	: l=aexpr2 { $value = l; }
		(   MUL r1=aexpr2 { $value = new ArithmeticOperation($value, ArithmeticOperator.Multiply, r1); } 
		  | DIV r2=aexpr2 { $value = new ArithmeticOperation($value, ArithmeticOperator.Divide, r2); } 
		)* 
	;

aexpr2 returns [ArithmeticExpression value]
	: MINUS a1=aexpr3 { $value = new UnaryMinus(a1); }
    |       a2=aexpr3 { $value = a2; }
    ;

aexpr3 returns [ArithmeticExpression value] 
	: IDENTIFIER                     { $value = new Identifier($IDENTIFIER.getText()); }
		( LBRACKET a1=aexpr RBRACKET { $value = new ArithmeticArray($value, a1); } 
		)?
    | INTEGER                        { $value = new Constant(Integer.parseInt( $INTEGER.getText() )); }
    | LPAREN a2=aexpr RPAREN         { $value = a2; }
    ;

program returns [ArithmeticExpression value]
	: a=aexpr { $value = a; }
	;

/*
bexpr : bexpr1 (OR bexpr1)*
      ;

bexpr1 : bexpr2 (AND bexpr2)*
       ;

bexpr2 : aexpr opr aexpr
       | NOT bexpr
       | TRUE
       | FALSE
       | LPAREN bexpr RPAREN
       ;

opr : GT
    | GE
    | LT
    | LE
    | EQ
    | NEQ
    ;

decl returns [Declaration value] 
	: INT IDENTIFIER (LBRACKET INTEGER RBRACKET)? SEMI ;

level : LOW | HIGH ;

stmt returns [Statement value] 
	: assignStmt
    | skipStmt
    | readStmt
    | writeStmt
    | ifStmt
    | whileStmt
    ;

assignStmt returns [Assignment value]
	: IDENTIFIER (LBRACKET aexpr RBRACKET)? ASSIGN exp=aexpr SEMI { $value = new Assignment($IDENTIFIER.getText(), exp); }
	;

skipStmt returns [SkipStatement value]
	: SKIP SEMI { $value = new SkipStatement(); }
	;

readStmt : READ IDENTIFIER (LBRACKET aexpr RBRACKET)? SEMI ;

writeStmt : WRITE aexpr SEMI ;

ifStmt : IF bexpr THEN stmt+ ELSE stmt+ FI ;

whileStmt : WHILE bexpr DO stmt+ OD ;
*/

COMMENT : '(*' (options {greedy=false;} : .)* '*)' {$channel=HIDDEN;}
     ;

INTEGER : ('0' | '1'..'9' '0'..'9'*);

IDENTIFIER : LETTER (LETTER|'0'..'9')* ;

fragment
LETTER : 'A'..'Z'
       | 'a'..'z'
       | '_'
       ;

WS : (' '|'\r'|'\t'|'\u000C'|'\n') { skip(); } ;
